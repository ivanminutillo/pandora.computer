schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Category {
  id: ID!
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!
}

input Category_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numConditions: Int
  numConditions_not: Int
  numConditions_gt: Int
  numConditions_lt: Int
  numConditions_gte: Int
  numConditions_lte: Int
  numConditions_in: [Int!]
  numConditions_not_in: [Int!]
  numOpenConditions: Int
  numOpenConditions_not: Int
  numOpenConditions_gt: Int
  numOpenConditions_lt: Int
  numOpenConditions_gte: Int
  numOpenConditions_lte: Int
  numOpenConditions_in: [Int!]
  numOpenConditions_not_in: [Int!]
  numClosedConditions: Int
  numClosedConditions_not: Int
  numClosedConditions_gt: Int
  numClosedConditions_lt: Int
  numClosedConditions_gte: Int
  numClosedConditions_lte: Int
  numClosedConditions_in: [Int!]
  numClosedConditions_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Category_filter]
  or: [Category_filter]
}

enum Category_orderBy {
  id
  numConditions
  numOpenConditions
  numClosedConditions
}

type CollateralToken {
  id: ID!
  activeAmount: BigInt!
  splitAmount: BigInt!
  mergedAmount: BigInt!
  redeemedAmount: BigInt!
  positions(skip: Int = 0, first: Int = 100, orderBy: Position_orderBy, orderDirection: OrderDirection, where: Position_filter): [Position!]
}

input CollateralToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  activeAmount: BigInt
  activeAmount_not: BigInt
  activeAmount_gt: BigInt
  activeAmount_lt: BigInt
  activeAmount_gte: BigInt
  activeAmount_lte: BigInt
  activeAmount_in: [BigInt!]
  activeAmount_not_in: [BigInt!]
  splitAmount: BigInt
  splitAmount_not: BigInt
  splitAmount_gt: BigInt
  splitAmount_lt: BigInt
  splitAmount_gte: BigInt
  splitAmount_lte: BigInt
  splitAmount_in: [BigInt!]
  splitAmount_not_in: [BigInt!]
  mergedAmount: BigInt
  mergedAmount_not: BigInt
  mergedAmount_gt: BigInt
  mergedAmount_lt: BigInt
  mergedAmount_gte: BigInt
  mergedAmount_lte: BigInt
  mergedAmount_in: [BigInt!]
  mergedAmount_not_in: [BigInt!]
  redeemedAmount: BigInt
  redeemedAmount_not: BigInt
  redeemedAmount_gt: BigInt
  redeemedAmount_lt: BigInt
  redeemedAmount_gte: BigInt
  redeemedAmount_lte: BigInt
  redeemedAmount_in: [BigInt!]
  redeemedAmount_not_in: [BigInt!]
  positions_: Position_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralToken_filter]
  or: [CollateralToken_filter]
}

enum CollateralToken_orderBy {
  id
  activeAmount
  splitAmount
  mergedAmount
  redeemedAmount
  positions
}

type Collection {
  id: ID!
  conditions(skip: Int = 0, first: Int = 100, orderBy: Condition_orderBy, orderDirection: OrderDirection, where: Condition_filter): [Condition!]!
  conditionIds: [ID!]!
  conditionIdsStr: String!
  indexSets: [BigInt!]!
  multiplicities: [Int!]!
  positions(skip: Int = 0, first: Int = 100, orderBy: Position_orderBy, orderDirection: OrderDirection, where: Position_filter): [Position!]
}

input Collection_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  conditions: [String!]
  conditions_not: [String!]
  conditions_contains: [String!]
  conditions_contains_nocase: [String!]
  conditions_not_contains: [String!]
  conditions_not_contains_nocase: [String!]
  conditions_: Condition_filter
  conditionIds: [ID!]
  conditionIds_not: [ID!]
  conditionIds_contains: [ID!]
  conditionIds_contains_nocase: [ID!]
  conditionIds_not_contains: [ID!]
  conditionIds_not_contains_nocase: [ID!]
  conditionIdsStr: String
  conditionIdsStr_not: String
  conditionIdsStr_gt: String
  conditionIdsStr_lt: String
  conditionIdsStr_gte: String
  conditionIdsStr_lte: String
  conditionIdsStr_in: [String!]
  conditionIdsStr_not_in: [String!]
  conditionIdsStr_contains: String
  conditionIdsStr_contains_nocase: String
  conditionIdsStr_not_contains: String
  conditionIdsStr_not_contains_nocase: String
  conditionIdsStr_starts_with: String
  conditionIdsStr_starts_with_nocase: String
  conditionIdsStr_not_starts_with: String
  conditionIdsStr_not_starts_with_nocase: String
  conditionIdsStr_ends_with: String
  conditionIdsStr_ends_with_nocase: String
  conditionIdsStr_not_ends_with: String
  conditionIdsStr_not_ends_with_nocase: String
  indexSets: [BigInt!]
  indexSets_not: [BigInt!]
  indexSets_contains: [BigInt!]
  indexSets_contains_nocase: [BigInt!]
  indexSets_not_contains: [BigInt!]
  indexSets_not_contains_nocase: [BigInt!]
  multiplicities: [Int!]
  multiplicities_not: [Int!]
  multiplicities_contains: [Int!]
  multiplicities_contains_nocase: [Int!]
  multiplicities_not_contains: [Int!]
  multiplicities_not_contains_nocase: [Int!]
  positions_: Position_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Collection_filter]
  or: [Collection_filter]
}

enum Collection_orderBy {
  id
  conditions
  conditionIds
  conditionIdsStr
  indexSets
  multiplicities
  positions
}

type Condition {
  id: ID!
  conditionId: String!
  oracle: String!
  questionId: String!
  outcomeSlotCount: Int!
  creator: String!
  createTransaction: Bytes!
  createTimestamp: BigInt!
  createBlockNumber: BigInt!
  resolved: Boolean!
  resolveTransaction: Bytes
  resolveTimestamp: BigInt
  resolveBlockNumber: BigInt
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  payouts: [BigDecimal!]
  question: Question
  title: String
  outcomes: [String!]
  scalarLow: BigInt
  scalarHigh: BigInt
  collections(skip: Int = 0, first: Int = 100, orderBy: Collection_orderBy, orderDirection: OrderDirection, where: Collection_filter): [Collection!]
  positions(skip: Int = 0, first: Int = 100, orderBy: Position_orderBy, orderDirection: OrderDirection, where: Position_filter): [Position!]
}

input Condition_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  conditionId: String
  conditionId_not: String
  conditionId_gt: String
  conditionId_lt: String
  conditionId_gte: String
  conditionId_lte: String
  conditionId_in: [String!]
  conditionId_not_in: [String!]
  conditionId_contains: String
  conditionId_contains_nocase: String
  conditionId_not_contains: String
  conditionId_not_contains_nocase: String
  conditionId_starts_with: String
  conditionId_starts_with_nocase: String
  conditionId_not_starts_with: String
  conditionId_not_starts_with_nocase: String
  conditionId_ends_with: String
  conditionId_ends_with_nocase: String
  conditionId_not_ends_with: String
  conditionId_not_ends_with_nocase: String
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  questionId: String
  questionId_not: String
  questionId_gt: String
  questionId_lt: String
  questionId_gte: String
  questionId_lte: String
  questionId_in: [String!]
  questionId_not_in: [String!]
  questionId_contains: String
  questionId_contains_nocase: String
  questionId_not_contains: String
  questionId_not_contains_nocase: String
  questionId_starts_with: String
  questionId_starts_with_nocase: String
  questionId_not_starts_with: String
  questionId_not_starts_with_nocase: String
  questionId_ends_with: String
  questionId_ends_with_nocase: String
  questionId_not_ends_with: String
  questionId_not_ends_with_nocase: String
  outcomeSlotCount: Int
  outcomeSlotCount_not: Int
  outcomeSlotCount_gt: Int
  outcomeSlotCount_lt: Int
  outcomeSlotCount_gte: Int
  outcomeSlotCount_lte: Int
  outcomeSlotCount_in: [Int!]
  outcomeSlotCount_not_in: [Int!]
  creator: String
  creator_not: String
  creator_gt: String
  creator_lt: String
  creator_gte: String
  creator_lte: String
  creator_in: [String!]
  creator_not_in: [String!]
  creator_contains: String
  creator_contains_nocase: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  createTransaction: Bytes
  createTransaction_not: Bytes
  createTransaction_gt: Bytes
  createTransaction_lt: Bytes
  createTransaction_gte: Bytes
  createTransaction_lte: Bytes
  createTransaction_in: [Bytes!]
  createTransaction_not_in: [Bytes!]
  createTransaction_contains: Bytes
  createTransaction_not_contains: Bytes
  createTimestamp: BigInt
  createTimestamp_not: BigInt
  createTimestamp_gt: BigInt
  createTimestamp_lt: BigInt
  createTimestamp_gte: BigInt
  createTimestamp_lte: BigInt
  createTimestamp_in: [BigInt!]
  createTimestamp_not_in: [BigInt!]
  createBlockNumber: BigInt
  createBlockNumber_not: BigInt
  createBlockNumber_gt: BigInt
  createBlockNumber_lt: BigInt
  createBlockNumber_gte: BigInt
  createBlockNumber_lte: BigInt
  createBlockNumber_in: [BigInt!]
  createBlockNumber_not_in: [BigInt!]
  resolved: Boolean
  resolved_not: Boolean
  resolved_in: [Boolean!]
  resolved_not_in: [Boolean!]
  resolveTransaction: Bytes
  resolveTransaction_not: Bytes
  resolveTransaction_gt: Bytes
  resolveTransaction_lt: Bytes
  resolveTransaction_gte: Bytes
  resolveTransaction_lte: Bytes
  resolveTransaction_in: [Bytes!]
  resolveTransaction_not_in: [Bytes!]
  resolveTransaction_contains: Bytes
  resolveTransaction_not_contains: Bytes
  resolveTimestamp: BigInt
  resolveTimestamp_not: BigInt
  resolveTimestamp_gt: BigInt
  resolveTimestamp_lt: BigInt
  resolveTimestamp_gte: BigInt
  resolveTimestamp_lte: BigInt
  resolveTimestamp_in: [BigInt!]
  resolveTimestamp_not_in: [BigInt!]
  resolveBlockNumber: BigInt
  resolveBlockNumber_not: BigInt
  resolveBlockNumber_gt: BigInt
  resolveBlockNumber_lt: BigInt
  resolveBlockNumber_gte: BigInt
  resolveBlockNumber_lte: BigInt
  resolveBlockNumber_in: [BigInt!]
  resolveBlockNumber_not_in: [BigInt!]
  payoutNumerators: [BigInt!]
  payoutNumerators_not: [BigInt!]
  payoutNumerators_contains: [BigInt!]
  payoutNumerators_contains_nocase: [BigInt!]
  payoutNumerators_not_contains: [BigInt!]
  payoutNumerators_not_contains_nocase: [BigInt!]
  payoutDenominator: BigInt
  payoutDenominator_not: BigInt
  payoutDenominator_gt: BigInt
  payoutDenominator_lt: BigInt
  payoutDenominator_gte: BigInt
  payoutDenominator_lte: BigInt
  payoutDenominator_in: [BigInt!]
  payoutDenominator_not_in: [BigInt!]
  payouts: [BigDecimal!]
  payouts_not: [BigDecimal!]
  payouts_contains: [BigDecimal!]
  payouts_contains_nocase: [BigDecimal!]
  payouts_not_contains: [BigDecimal!]
  payouts_not_contains_nocase: [BigDecimal!]
  question: String
  question_not: String
  question_gt: String
  question_lt: String
  question_gte: String
  question_lte: String
  question_in: [String!]
  question_not_in: [String!]
  question_contains: String
  question_contains_nocase: String
  question_not_contains: String
  question_not_contains_nocase: String
  question_starts_with: String
  question_starts_with_nocase: String
  question_not_starts_with: String
  question_not_starts_with_nocase: String
  question_ends_with: String
  question_ends_with_nocase: String
  question_not_ends_with: String
  question_not_ends_with_nocase: String
  question_: Question_filter
  title: String
  title_not: String
  title_gt: String
  title_lt: String
  title_gte: String
  title_lte: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_contains_nocase: String
  title_not_contains: String
  title_not_contains_nocase: String
  title_starts_with: String
  title_starts_with_nocase: String
  title_not_starts_with: String
  title_not_starts_with_nocase: String
  title_ends_with: String
  title_ends_with_nocase: String
  title_not_ends_with: String
  title_not_ends_with_nocase: String
  outcomes: [String!]
  outcomes_not: [String!]
  outcomes_contains: [String!]
  outcomes_contains_nocase: [String!]
  outcomes_not_contains: [String!]
  outcomes_not_contains_nocase: [String!]
  scalarLow: BigInt
  scalarLow_not: BigInt
  scalarLow_gt: BigInt
  scalarLow_lt: BigInt
  scalarLow_gte: BigInt
  scalarLow_lte: BigInt
  scalarLow_in: [BigInt!]
  scalarLow_not_in: [BigInt!]
  scalarHigh: BigInt
  scalarHigh_not: BigInt
  scalarHigh_gt: BigInt
  scalarHigh_lt: BigInt
  scalarHigh_gte: BigInt
  scalarHigh_lte: BigInt
  scalarHigh_in: [BigInt!]
  scalarHigh_not_in: [BigInt!]
  collections_: Collection_filter
  positions_: Position_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Condition_filter]
  or: [Condition_filter]
}

enum Condition_orderBy {
  id
  conditionId
  oracle
  questionId
  outcomeSlotCount
  creator
  createTransaction
  createTimestamp
  createBlockNumber
  resolved
  resolveTransaction
  resolveTimestamp
  resolveBlockNumber
  payoutNumerators
  payoutDenominator
  payouts
  question
  question__id
  question__templateId
  question__data
  question__title
  question__category
  question__language
  question__arbitrator
  question__openingTimestamp
  question__timeout
  question__currentAnswer
  question__currentAnswerBond
  question__currentAnswerTimestamp
  question__isPendingArbitration
  question__arbitrationOccurred
  question__answerFinalizedTimestamp
  title
  outcomes
  scalarLow
  scalarHigh
  collections
  positions
}

type Global {
  id: ID!
  numConditions: Int!
  numCollections: Int!
  numPositions: Int!
}

input Global_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numConditions: Int
  numConditions_not: Int
  numConditions_gt: Int
  numConditions_lt: Int
  numConditions_gte: Int
  numConditions_lte: Int
  numConditions_in: [Int!]
  numConditions_not_in: [Int!]
  numCollections: Int
  numCollections_not: Int
  numCollections_gt: Int
  numCollections_lt: Int
  numCollections_gte: Int
  numCollections_lte: Int
  numCollections_in: [Int!]
  numCollections_not_in: [Int!]
  numPositions: Int
  numPositions_not: Int
  numPositions_gt: Int
  numPositions_lt: Int
  numPositions_gte: Int
  numPositions_lte: Int
  numPositions_in: [Int!]
  numPositions_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Global_filter]
  or: [Global_filter]
}

enum Global_orderBy {
  id
  numConditions
  numCollections
  numPositions
}

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Position {
  id: ID!
  positionId: String!
  collateralToken: CollateralToken!
  collateralTokenAddress: String!
  collection: Collection!
  conditions(skip: Int = 0, first: Int = 100, orderBy: Condition_orderBy, orderDirection: OrderDirection, where: Condition_filter): [Condition!]!
  conditionIds: [ID!]!
  conditionIdsStr: String!
  indexSets: [BigInt!]!
  multiplicities: [Int!]!
  createTimestamp: BigInt!
  lifetimeValue: BigInt!
  activeValue: BigInt!
  wrappedTokens(skip: Int = 0, first: Int = 100, orderBy: WrappedToken_orderBy, orderDirection: OrderDirection, where: WrappedToken_filter): [WrappedToken!]!
  wrappedTokenAddress: String
}

input Position_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  positionId: String
  positionId_not: String
  positionId_gt: String
  positionId_lt: String
  positionId_gte: String
  positionId_lte: String
  positionId_in: [String!]
  positionId_not_in: [String!]
  positionId_contains: String
  positionId_contains_nocase: String
  positionId_not_contains: String
  positionId_not_contains_nocase: String
  positionId_starts_with: String
  positionId_starts_with_nocase: String
  positionId_not_starts_with: String
  positionId_not_starts_with_nocase: String
  positionId_ends_with: String
  positionId_ends_with_nocase: String
  positionId_not_ends_with: String
  positionId_not_ends_with_nocase: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_: CollateralToken_filter
  collateralTokenAddress: String
  collateralTokenAddress_not: String
  collateralTokenAddress_gt: String
  collateralTokenAddress_lt: String
  collateralTokenAddress_gte: String
  collateralTokenAddress_lte: String
  collateralTokenAddress_in: [String!]
  collateralTokenAddress_not_in: [String!]
  collateralTokenAddress_contains: String
  collateralTokenAddress_contains_nocase: String
  collateralTokenAddress_not_contains: String
  collateralTokenAddress_not_contains_nocase: String
  collateralTokenAddress_starts_with: String
  collateralTokenAddress_starts_with_nocase: String
  collateralTokenAddress_not_starts_with: String
  collateralTokenAddress_not_starts_with_nocase: String
  collateralTokenAddress_ends_with: String
  collateralTokenAddress_ends_with_nocase: String
  collateralTokenAddress_not_ends_with: String
  collateralTokenAddress_not_ends_with_nocase: String
  collection: String
  collection_not: String
  collection_gt: String
  collection_lt: String
  collection_gte: String
  collection_lte: String
  collection_in: [String!]
  collection_not_in: [String!]
  collection_contains: String
  collection_contains_nocase: String
  collection_not_contains: String
  collection_not_contains_nocase: String
  collection_starts_with: String
  collection_starts_with_nocase: String
  collection_not_starts_with: String
  collection_not_starts_with_nocase: String
  collection_ends_with: String
  collection_ends_with_nocase: String
  collection_not_ends_with: String
  collection_not_ends_with_nocase: String
  collection_: Collection_filter
  conditions: [String!]
  conditions_not: [String!]
  conditions_contains: [String!]
  conditions_contains_nocase: [String!]
  conditions_not_contains: [String!]
  conditions_not_contains_nocase: [String!]
  conditions_: Condition_filter
  conditionIds: [ID!]
  conditionIds_not: [ID!]
  conditionIds_contains: [ID!]
  conditionIds_contains_nocase: [ID!]
  conditionIds_not_contains: [ID!]
  conditionIds_not_contains_nocase: [ID!]
  conditionIdsStr: String
  conditionIdsStr_not: String
  conditionIdsStr_gt: String
  conditionIdsStr_lt: String
  conditionIdsStr_gte: String
  conditionIdsStr_lte: String
  conditionIdsStr_in: [String!]
  conditionIdsStr_not_in: [String!]
  conditionIdsStr_contains: String
  conditionIdsStr_contains_nocase: String
  conditionIdsStr_not_contains: String
  conditionIdsStr_not_contains_nocase: String
  conditionIdsStr_starts_with: String
  conditionIdsStr_starts_with_nocase: String
  conditionIdsStr_not_starts_with: String
  conditionIdsStr_not_starts_with_nocase: String
  conditionIdsStr_ends_with: String
  conditionIdsStr_ends_with_nocase: String
  conditionIdsStr_not_ends_with: String
  conditionIdsStr_not_ends_with_nocase: String
  indexSets: [BigInt!]
  indexSets_not: [BigInt!]
  indexSets_contains: [BigInt!]
  indexSets_contains_nocase: [BigInt!]
  indexSets_not_contains: [BigInt!]
  indexSets_not_contains_nocase: [BigInt!]
  multiplicities: [Int!]
  multiplicities_not: [Int!]
  multiplicities_contains: [Int!]
  multiplicities_contains_nocase: [Int!]
  multiplicities_not_contains: [Int!]
  multiplicities_not_contains_nocase: [Int!]
  createTimestamp: BigInt
  createTimestamp_not: BigInt
  createTimestamp_gt: BigInt
  createTimestamp_lt: BigInt
  createTimestamp_gte: BigInt
  createTimestamp_lte: BigInt
  createTimestamp_in: [BigInt!]
  createTimestamp_not_in: [BigInt!]
  lifetimeValue: BigInt
  lifetimeValue_not: BigInt
  lifetimeValue_gt: BigInt
  lifetimeValue_lt: BigInt
  lifetimeValue_gte: BigInt
  lifetimeValue_lte: BigInt
  lifetimeValue_in: [BigInt!]
  lifetimeValue_not_in: [BigInt!]
  activeValue: BigInt
  activeValue_not: BigInt
  activeValue_gt: BigInt
  activeValue_lt: BigInt
  activeValue_gte: BigInt
  activeValue_lte: BigInt
  activeValue_in: [BigInt!]
  activeValue_not_in: [BigInt!]
  wrappedTokens_: WrappedToken_filter
  wrappedTokenAddress: String
  wrappedTokenAddress_not: String
  wrappedTokenAddress_gt: String
  wrappedTokenAddress_lt: String
  wrappedTokenAddress_gte: String
  wrappedTokenAddress_lte: String
  wrappedTokenAddress_in: [String!]
  wrappedTokenAddress_not_in: [String!]
  wrappedTokenAddress_contains: String
  wrappedTokenAddress_contains_nocase: String
  wrappedTokenAddress_not_contains: String
  wrappedTokenAddress_not_contains_nocase: String
  wrappedTokenAddress_starts_with: String
  wrappedTokenAddress_starts_with_nocase: String
  wrappedTokenAddress_not_starts_with: String
  wrappedTokenAddress_not_starts_with_nocase: String
  wrappedTokenAddress_ends_with: String
  wrappedTokenAddress_ends_with_nocase: String
  wrappedTokenAddress_not_ends_with: String
  wrappedTokenAddress_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Position_filter]
  or: [Position_filter]
}

enum Position_orderBy {
  id
  positionId
  collateralToken
  collateralToken__id
  collateralToken__activeAmount
  collateralToken__splitAmount
  collateralToken__mergedAmount
  collateralToken__redeemedAmount
  collateralTokenAddress
  collection
  collection__id
  collection__conditionIdsStr
  conditions
  conditionIds
  conditionIdsStr
  indexSets
  multiplicities
  createTimestamp
  lifetimeValue
  activeValue
  wrappedTokens
  wrappedTokenAddress
}

type Query {
  condition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Condition
  conditions(
    skip: Int = 0
    first: Int = 100
    orderBy: Condition_orderBy
    orderDirection: OrderDirection
    where: Condition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Condition!]!
  collection(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collection
  collections(
    skip: Int = 0
    first: Int = 100
    orderBy: Collection_orderBy
    orderDirection: OrderDirection
    where: Collection_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collection!]!
  position(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!
  userPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserPosition
  userPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: UserPosition_orderBy
    orderDirection: OrderDirection
    where: UserPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserPosition!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  collateralToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  wrappedToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrappedToken
  wrappedTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: WrappedToken_orderBy
    orderDirection: OrderDirection
    where: WrappedToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WrappedToken!]!
  question(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Question
  questions(
    skip: Int = 0
    first: Int = 100
    orderBy: Question_orderBy
    orderDirection: OrderDirection
    where: Question_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Question!]!
  category(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Category
  categories(
    skip: Int = 0
    first: Int = 100
    orderBy: Category_orderBy
    orderDirection: OrderDirection
    where: Category_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Category!]!
  scalarQuestionLink(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ScalarQuestionLink
  scalarQuestionLinks(
    skip: Int = 0
    first: Int = 100
    orderBy: ScalarQuestionLink_orderBy
    orderDirection: OrderDirection
    where: ScalarQuestionLink_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ScalarQuestionLink!]!
  global(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    skip: Int = 0
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    where: Global_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Global!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Question {
  id: ID!
  templateId: BigInt!
  data: String!
  title: String
  outcomes: [String!]
  category: String
  language: String
  arbitrator: String!
  openingTimestamp: BigInt!
  timeout: BigInt!
  currentAnswer: Bytes
  currentAnswerBond: BigInt
  currentAnswerTimestamp: BigInt
  isPendingArbitration: Boolean!
  arbitrationOccurred: Boolean!
  answerFinalizedTimestamp: BigInt
  conditions(skip: Int = 0, first: Int = 100, orderBy: Condition_orderBy, orderDirection: OrderDirection, where: Condition_filter): [Condition!]!
}

input Question_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  templateId: BigInt
  templateId_not: BigInt
  templateId_gt: BigInt
  templateId_lt: BigInt
  templateId_gte: BigInt
  templateId_lte: BigInt
  templateId_in: [BigInt!]
  templateId_not_in: [BigInt!]
  data: String
  data_not: String
  data_gt: String
  data_lt: String
  data_gte: String
  data_lte: String
  data_in: [String!]
  data_not_in: [String!]
  data_contains: String
  data_contains_nocase: String
  data_not_contains: String
  data_not_contains_nocase: String
  data_starts_with: String
  data_starts_with_nocase: String
  data_not_starts_with: String
  data_not_starts_with_nocase: String
  data_ends_with: String
  data_ends_with_nocase: String
  data_not_ends_with: String
  data_not_ends_with_nocase: String
  title: String
  title_not: String
  title_gt: String
  title_lt: String
  title_gte: String
  title_lte: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_contains_nocase: String
  title_not_contains: String
  title_not_contains_nocase: String
  title_starts_with: String
  title_starts_with_nocase: String
  title_not_starts_with: String
  title_not_starts_with_nocase: String
  title_ends_with: String
  title_ends_with_nocase: String
  title_not_ends_with: String
  title_not_ends_with_nocase: String
  outcomes: [String!]
  outcomes_not: [String!]
  outcomes_contains: [String!]
  outcomes_contains_nocase: [String!]
  outcomes_not_contains: [String!]
  outcomes_not_contains_nocase: [String!]
  category: String
  category_not: String
  category_gt: String
  category_lt: String
  category_gte: String
  category_lte: String
  category_in: [String!]
  category_not_in: [String!]
  category_contains: String
  category_contains_nocase: String
  category_not_contains: String
  category_not_contains_nocase: String
  category_starts_with: String
  category_starts_with_nocase: String
  category_not_starts_with: String
  category_not_starts_with_nocase: String
  category_ends_with: String
  category_ends_with_nocase: String
  category_not_ends_with: String
  category_not_ends_with_nocase: String
  language: String
  language_not: String
  language_gt: String
  language_lt: String
  language_gte: String
  language_lte: String
  language_in: [String!]
  language_not_in: [String!]
  language_contains: String
  language_contains_nocase: String
  language_not_contains: String
  language_not_contains_nocase: String
  language_starts_with: String
  language_starts_with_nocase: String
  language_not_starts_with: String
  language_not_starts_with_nocase: String
  language_ends_with: String
  language_ends_with_nocase: String
  language_not_ends_with: String
  language_not_ends_with_nocase: String
  arbitrator: String
  arbitrator_not: String
  arbitrator_gt: String
  arbitrator_lt: String
  arbitrator_gte: String
  arbitrator_lte: String
  arbitrator_in: [String!]
  arbitrator_not_in: [String!]
  arbitrator_contains: String
  arbitrator_contains_nocase: String
  arbitrator_not_contains: String
  arbitrator_not_contains_nocase: String
  arbitrator_starts_with: String
  arbitrator_starts_with_nocase: String
  arbitrator_not_starts_with: String
  arbitrator_not_starts_with_nocase: String
  arbitrator_ends_with: String
  arbitrator_ends_with_nocase: String
  arbitrator_not_ends_with: String
  arbitrator_not_ends_with_nocase: String
  openingTimestamp: BigInt
  openingTimestamp_not: BigInt
  openingTimestamp_gt: BigInt
  openingTimestamp_lt: BigInt
  openingTimestamp_gte: BigInt
  openingTimestamp_lte: BigInt
  openingTimestamp_in: [BigInt!]
  openingTimestamp_not_in: [BigInt!]
  timeout: BigInt
  timeout_not: BigInt
  timeout_gt: BigInt
  timeout_lt: BigInt
  timeout_gte: BigInt
  timeout_lte: BigInt
  timeout_in: [BigInt!]
  timeout_not_in: [BigInt!]
  currentAnswer: Bytes
  currentAnswer_not: Bytes
  currentAnswer_gt: Bytes
  currentAnswer_lt: Bytes
  currentAnswer_gte: Bytes
  currentAnswer_lte: Bytes
  currentAnswer_in: [Bytes!]
  currentAnswer_not_in: [Bytes!]
  currentAnswer_contains: Bytes
  currentAnswer_not_contains: Bytes
  currentAnswerBond: BigInt
  currentAnswerBond_not: BigInt
  currentAnswerBond_gt: BigInt
  currentAnswerBond_lt: BigInt
  currentAnswerBond_gte: BigInt
  currentAnswerBond_lte: BigInt
  currentAnswerBond_in: [BigInt!]
  currentAnswerBond_not_in: [BigInt!]
  currentAnswerTimestamp: BigInt
  currentAnswerTimestamp_not: BigInt
  currentAnswerTimestamp_gt: BigInt
  currentAnswerTimestamp_lt: BigInt
  currentAnswerTimestamp_gte: BigInt
  currentAnswerTimestamp_lte: BigInt
  currentAnswerTimestamp_in: [BigInt!]
  currentAnswerTimestamp_not_in: [BigInt!]
  isPendingArbitration: Boolean
  isPendingArbitration_not: Boolean
  isPendingArbitration_in: [Boolean!]
  isPendingArbitration_not_in: [Boolean!]
  arbitrationOccurred: Boolean
  arbitrationOccurred_not: Boolean
  arbitrationOccurred_in: [Boolean!]
  arbitrationOccurred_not_in: [Boolean!]
  answerFinalizedTimestamp: BigInt
  answerFinalizedTimestamp_not: BigInt
  answerFinalizedTimestamp_gt: BigInt
  answerFinalizedTimestamp_lt: BigInt
  answerFinalizedTimestamp_gte: BigInt
  answerFinalizedTimestamp_lte: BigInt
  answerFinalizedTimestamp_in: [BigInt!]
  answerFinalizedTimestamp_not_in: [BigInt!]
  conditions_: Condition_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Question_filter]
  or: [Question_filter]
}

enum Question_orderBy {
  id
  templateId
  data
  title
  outcomes
  category
  language
  arbitrator
  openingTimestamp
  timeout
  currentAnswer
  currentAnswerBond
  currentAnswerTimestamp
  isPendingArbitration
  arbitrationOccurred
  answerFinalizedTimestamp
  conditions
}

type ScalarQuestionLink {
  id: ID!
  conditionQuestionId: Bytes!
  realityEthQuestionId: Bytes!
  question: Question
  scalarLow: BigInt!
  scalarHigh: BigInt!
}

input ScalarQuestionLink_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  conditionQuestionId: Bytes
  conditionQuestionId_not: Bytes
  conditionQuestionId_gt: Bytes
  conditionQuestionId_lt: Bytes
  conditionQuestionId_gte: Bytes
  conditionQuestionId_lte: Bytes
  conditionQuestionId_in: [Bytes!]
  conditionQuestionId_not_in: [Bytes!]
  conditionQuestionId_contains: Bytes
  conditionQuestionId_not_contains: Bytes
  realityEthQuestionId: Bytes
  realityEthQuestionId_not: Bytes
  realityEthQuestionId_gt: Bytes
  realityEthQuestionId_lt: Bytes
  realityEthQuestionId_gte: Bytes
  realityEthQuestionId_lte: Bytes
  realityEthQuestionId_in: [Bytes!]
  realityEthQuestionId_not_in: [Bytes!]
  realityEthQuestionId_contains: Bytes
  realityEthQuestionId_not_contains: Bytes
  question: String
  question_not: String
  question_gt: String
  question_lt: String
  question_gte: String
  question_lte: String
  question_in: [String!]
  question_not_in: [String!]
  question_contains: String
  question_contains_nocase: String
  question_not_contains: String
  question_not_contains_nocase: String
  question_starts_with: String
  question_starts_with_nocase: String
  question_not_starts_with: String
  question_not_starts_with_nocase: String
  question_ends_with: String
  question_ends_with_nocase: String
  question_not_ends_with: String
  question_not_ends_with_nocase: String
  question_: Question_filter
  scalarLow: BigInt
  scalarLow_not: BigInt
  scalarLow_gt: BigInt
  scalarLow_lt: BigInt
  scalarLow_gte: BigInt
  scalarLow_lte: BigInt
  scalarLow_in: [BigInt!]
  scalarLow_not_in: [BigInt!]
  scalarHigh: BigInt
  scalarHigh_not: BigInt
  scalarHigh_gt: BigInt
  scalarHigh_lt: BigInt
  scalarHigh_gte: BigInt
  scalarHigh_lte: BigInt
  scalarHigh_in: [BigInt!]
  scalarHigh_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ScalarQuestionLink_filter]
  or: [ScalarQuestionLink_filter]
}

enum ScalarQuestionLink_orderBy {
  id
  conditionQuestionId
  realityEthQuestionId
  question
  question__id
  question__templateId
  question__data
  question__title
  question__category
  question__language
  question__arbitrator
  question__openingTimestamp
  question__timeout
  question__currentAnswer
  question__currentAnswerBond
  question__currentAnswerTimestamp
  question__isPendingArbitration
  question__arbitrationOccurred
  question__answerFinalizedTimestamp
  scalarLow
  scalarHigh
}

type Subscription {
  condition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Condition
  conditions(
    skip: Int = 0
    first: Int = 100
    orderBy: Condition_orderBy
    orderDirection: OrderDirection
    where: Condition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Condition!]!
  collection(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collection
  collections(
    skip: Int = 0
    first: Int = 100
    orderBy: Collection_orderBy
    orderDirection: OrderDirection
    where: Collection_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collection!]!
  position(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Position
  positions(
    skip: Int = 0
    first: Int = 100
    orderBy: Position_orderBy
    orderDirection: OrderDirection
    where: Position_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Position!]!
  userPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserPosition
  userPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: UserPosition_orderBy
    orderDirection: OrderDirection
    where: UserPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserPosition!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  collateralToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  wrappedToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WrappedToken
  wrappedTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: WrappedToken_orderBy
    orderDirection: OrderDirection
    where: WrappedToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WrappedToken!]!
  question(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Question
  questions(
    skip: Int = 0
    first: Int = 100
    orderBy: Question_orderBy
    orderDirection: OrderDirection
    where: Question_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Question!]!
  category(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Category
  categories(
    skip: Int = 0
    first: Int = 100
    orderBy: Category_orderBy
    orderDirection: OrderDirection
    where: Category_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Category!]!
  scalarQuestionLink(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ScalarQuestionLink
  scalarQuestionLinks(
    skip: Int = 0
    first: Int = 100
    orderBy: ScalarQuestionLink_orderBy
    orderDirection: OrderDirection
    where: ScalarQuestionLink_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ScalarQuestionLink!]!
  global(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Global
  globals(
    skip: Int = 0
    first: Int = 100
    orderBy: Global_orderBy
    orderDirection: OrderDirection
    where: Global_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Global!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type User {
  id: ID!
  firstParticipation: BigInt!
  lastActive: BigInt!
  userPositions(skip: Int = 0, first: Int = 100, orderBy: UserPosition_orderBy, orderDirection: OrderDirection, where: UserPosition_filter): [UserPosition!]
}

type UserPosition {
  id: ID!
  position: Position!
  balance: BigInt!
  wrappedBalance: BigInt!
  totalBalance: BigInt!
  user: User!
}

input UserPosition_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  position: String
  position_not: String
  position_gt: String
  position_lt: String
  position_gte: String
  position_lte: String
  position_in: [String!]
  position_not_in: [String!]
  position_contains: String
  position_contains_nocase: String
  position_not_contains: String
  position_not_contains_nocase: String
  position_starts_with: String
  position_starts_with_nocase: String
  position_not_starts_with: String
  position_not_starts_with_nocase: String
  position_ends_with: String
  position_ends_with_nocase: String
  position_not_ends_with: String
  position_not_ends_with_nocase: String
  position_: Position_filter
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  wrappedBalance: BigInt
  wrappedBalance_not: BigInt
  wrappedBalance_gt: BigInt
  wrappedBalance_lt: BigInt
  wrappedBalance_gte: BigInt
  wrappedBalance_lte: BigInt
  wrappedBalance_in: [BigInt!]
  wrappedBalance_not_in: [BigInt!]
  totalBalance: BigInt
  totalBalance_not: BigInt
  totalBalance_gt: BigInt
  totalBalance_lt: BigInt
  totalBalance_gte: BigInt
  totalBalance_lte: BigInt
  totalBalance_in: [BigInt!]
  totalBalance_not_in: [BigInt!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UserPosition_filter]
  or: [UserPosition_filter]
}

enum UserPosition_orderBy {
  id
  position
  position__id
  position__positionId
  position__collateralTokenAddress
  position__conditionIdsStr
  position__createTimestamp
  position__lifetimeValue
  position__activeValue
  position__wrappedTokenAddress
  balance
  wrappedBalance
  totalBalance
  user
  user__id
  user__firstParticipation
  user__lastActive
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  firstParticipation: BigInt
  firstParticipation_not: BigInt
  firstParticipation_gt: BigInt
  firstParticipation_lt: BigInt
  firstParticipation_gte: BigInt
  firstParticipation_lte: BigInt
  firstParticipation_in: [BigInt!]
  firstParticipation_not_in: [BigInt!]
  lastActive: BigInt
  lastActive_not: BigInt
  lastActive_gt: BigInt
  lastActive_lt: BigInt
  lastActive_gte: BigInt
  lastActive_lte: BigInt
  lastActive_in: [BigInt!]
  lastActive_not_in: [BigInt!]
  userPositions_: UserPosition_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  firstParticipation
  lastActive
  userPositions
}

type WrappedToken {
  id: ID!
  position: Position!
}

input WrappedToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  position: String
  position_not: String
  position_gt: String
  position_lt: String
  position_gte: String
  position_lte: String
  position_in: [String!]
  position_not_in: [String!]
  position_contains: String
  position_contains_nocase: String
  position_not_contains: String
  position_not_contains_nocase: String
  position_starts_with: String
  position_starts_with_nocase: String
  position_not_starts_with: String
  position_not_starts_with_nocase: String
  position_ends_with: String
  position_ends_with_nocase: String
  position_not_ends_with: String
  position_not_ends_with_nocase: String
  position_: Position_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [WrappedToken_filter]
  or: [WrappedToken_filter]
}

enum WrappedToken_orderBy {
  id
  position
  position__id
  position__positionId
  position__collateralTokenAddress
  position__conditionIdsStr
  position__createTimestamp
  position__lifetimeValue
  position__activeValue
  position__wrappedTokenAddress
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
// @ts-nocheck
// ignore ts
'use client';

import { useState, useEffect } from 'react';
import { useTable } from 'react-table';

const STATS_TABLE_COLS = ['Open', 'Pending', 'Finalizing', 'Arbitrating', 'Closed', 'Unknown', 'TOTAL'];
const STATS_TABLE_ROWS = [
  'Num_trades',
  'Winner_trades',
  'Num_redeemed',
  'Mech_calls',
  'Investment',
  'Fees',
  'Mech_fees',
  'Earnings',
  'Net_earnings',
  'Redemptions',
  'ROI',
];

function weiToXDai(wei:any) {
  return `${(wei / 10 ** 18).toFixed(2)} xDAI`;
}

function computeROI(initialValue:any, finalValue:any) {
  if (initialValue !== 0) {
    return (finalValue - initialValue) / initialValue;
  }
  return 0;
}

function getMarketState(market:any) {
  const now = new Date();
  const openingTimestamp = market.openingTimestamp ? new Date(parseInt(market.openingTimestamp) * 1000) : null;
  const answerFinalizedTimestamp = market.answerFinalizedTimestamp ? new Date(parseInt(market.answerFinalizedTimestamp) * 1000) : null;

  if (market.currentAnswer === null && openingTimestamp && now >= openingTimestamp) {
    return 'Pending';
  } else if (market.currentAnswer === null) {
    return 'Open';
  } else if (market.isPendingArbitration) {
    return 'Arbitrating';
  } else if (answerFinalizedTimestamp && now < answerFinalizedTimestamp) {
    return 'Finalizing';
  } else if (answerFinalizedTimestamp && now >= answerFinalizedTimestamp) {
    return 'Closed';
  } else {
    return 'Unknown';
  }
}

function SummaryTable({ trades, userPositions, shouldFetchTrades }) {
  useEffect(() => {
    const statisticsTable = STATS_TABLE_ROWS.reduce((acc, row) => {
      acc[row] = STATS_TABLE_COLS.reduce((colAcc, col) => {
        colAcc[col] = 0;
        return colAcc;
      }, {});
      return acc;
    }, [trades, userPositions]);

    // Process trades and update statistics table
    trades.forEach((trade) => {
      const marketStatus = getMarketState(trade.fpmm);
      statisticsTable['Num_trades'][marketStatus] += 1;
      statisticsTable['Investment'][marketStatus] += parseInt(trade.collateralAmount);
      statisticsTable['Fees'][marketStatus] += parseInt(trade.feeAmount);
      // Update other statistics based on trade data
    });

    // Process user positions and update statistics table
    userPositions.forEach((position) => {
      // Update statistics based on user position data
    });

    // Compute totals and update statistics table
    STATS_TABLE_ROWS.forEach((row) => {
      statisticsTable[row]['TOTAL'] = STATS_TABLE_COLS.reduce(
        (sum, col) => sum + statisticsTable[row][col],
        0
      );
    });

    // Compute ROI and format data for the table
    const tableData = STATS_TABLE_ROWS.map((row) => {
      const rowData = STATS_TABLE_COLS.reduce((acc, col) => {
        if (row === 'ROI') {
          acc[col] = `${(computeROI(
            statisticsTable['Investment'][col] + statisticsTable['Fees'][col] + statisticsTable['Mech_fees'][col],
            statisticsTable['Earnings'][col]
          ) * 100).toFixed(2)}%`;
        } else if (['Investment', 'Fees', 'Mech_fees', 'Earnings', 'Net_earnings', 'Redemptions'].includes(row)) {
          acc[col] = weiToXDai(statisticsTable[row][col]);
        } else {
          acc[col] = statisticsTable[row][col];
        }
        return acc;
      }, {});
      return { attribute: row, ...rowData };
    });

    // Log the table data to the console
    console.log('Summary Table:');
    console.table(tableData);
  }, [trades, userPositions, shouldFetchTrades]); 

  return (
    <div>{userPositions.length}</div>
  );
}
export default function Home() {
    const [trades, setTrades] = useState([]);
    const [userPositions, setUserPositions] = useState([]);
    const [shouldFetchTrades, setShouldFetchTrades] = useState(false);


  const fetchTrades = async () => {
    const creator = ('0xdafebbc0767F24BD84091870205b64ec5c5cBC4D').toLowerCase();
    const fromTimestamp = Math.floor(new Date('2024-01-01T00:00:00Z').getTime() / 1000);
    const toTimestamp = Math.floor(new Date('2024-04-23T23:14:07Z').getTime() / 1000);
    const fpmmFromTimestamp = fromTimestamp;
    const fpmmToTimestamp = toTimestamp;

    try {
      const response = await fetch('/api/trades', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ creator, fromTimestamp, toTimestamp, fpmmFromTimestamp, fpmmToTimestamp }),
      });
  
      if (!response.ok) {
        console.log('response', response);
        throw new Error('Network response was not ok');
      }
  
      const data = await response.json();
      console.log(data)
      setTrades(data.trades);
      setUserPositions(data.userPositions);
      setShouldFetchTrades(true);

    } catch (error) {
      console.error('Failed to fetch trades:', error);
      // Handle the error appropriately in your UI
    }
  };

  return (
    <div>
      <h1>Trades and User Positions</h1>
      <button onClick={fetchTrades}>Fetch Trades</button>
      <SummaryTable trades={trades} userPositions={userPositions} shouldFetchTrades={shouldFetchTrades} />
      <h2>Trades</h2>
      <pre>{JSON.stringify(trades, null, 2)}</pre>
      <h2>User Positions</h2>
      <pre>{JSON.stringify(userPositions, null, 2)}</pre>

    </div>
  );
}

// 'use client'
// import { useState } from 'react';

// export default function Home() {
//   const [trades, setTrades] = useState([]);
//   const [userPositions, setUserPositions] = useState([]);

//   const fetchTrades = async () => {
//     const creator = '0xdafebbc0767F24BD84091870205b64ec5c5cBC4D';
//     const fromTimestamp = Math.floor(new Date('1970-01-01T00:00:00Z').getTime() / 1000);
//     const toTimestamp = Math.floor(new Date('2038-01-19T03:14:07Z').getTime() / 1000);
//     const fpmmFromTimestamp = fromTimestamp;
//     const fpmmToTimestamp = toTimestamp;

//     try {
//       const response = await fetch('/api/trades', {
//         method: 'POST',
//         headers: {
//           'Content-Type': 'application/json',
//         },
//         body: JSON.stringify({ creator, fromTimestamp, toTimestamp, fpmmFromTimestamp, fpmmToTimestamp }),
//       });
  
//       if (!response.ok) {
//         console.log('response', response);
//         throw new Error('Network response was not ok');
//       }
  
//       const data = await response.json();
//       setTrades(data.trades);
//       setUserPositions(data.userPositions);
//     } catch (error) {
//       console.error('Failed to fetch trades:', error);
//       // Handle the error appropriately in your UI
//     }

   
//   };

//   return (
//     <div>
//       <h1>Trades and User Positions</h1>
//       <button onClick={fetchTrades}>Fetch Trades</button>
//       <h2>Trades</h2>
//       <pre>{JSON.stringify(trades, null, 2)}</pre>
//       <h2>User Positions</h2>
//       <pre>{JSON.stringify(userPositions, null, 2)}</pre>
//     </div>
//   );
// }